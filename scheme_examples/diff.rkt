'(define *levenshtein-obj* (new-levenshtein))
'(define levenshtein (lambda (l r) (edit-distance *levenshtein-obj* l r)))
'(define reduce (lambda (op z lst) (if (null? lst) (begin z) (begin (reduce op (op z (car lst)) (cdr lst))))))
'(define flatten (lambda (lst) (if (null? lst) (begin (quote ())) (if (list? lst) (begin (append (flatten (car lst)) (flatten (cdr lst)))) (begin (list lst))))))
'(define hash-adjust (lambda (m key func) (define value (hash-try-get m key)) (if value (hash-insert m key (func value)) m)))
'(define bk-empty? (lambda (bktree) (if (equal? "" (BKTree-s bktree)) (zero? (hash-length (BKTree-children bktree))) #false)))
'(define empty-bk-tree (BKTree "" (hash)))
'(define insert-word (lambda (bktree new-word) (define children-map (BKTree-children bktree)) (define root-word (BKTree-s bktree)) (define dist (levenshtein root-word new-word)) (if (bk-empty? bktree) (begin (BKTree new-word (hash))) (if (hash-try-get children-map dist) (begin (define children (hash-adjust children-map dist (lambda (x) (insert-word x new-word)))) (BKTree root-word children)) (begin (define children (hash-insert children-map dist (BKTree new-word (hash)))) (BKTree root-word children))))))
'(define query (lambda (n query-word bktree) (define root-word (BKTree-s bktree)) (define ts (BKTree-children bktree)) (define d (levenshtein root-word query-word)) (define lower ((lambda (res) (if (< res 0) (* -1 res) res)) (- d n))) (define upper (+ d n)) (define cs (filter (lambda (x) (if x #true #false)) (map (lambda (y) (hash-try-get ts y)) (range lower upper)))) (define ms (flatten (map (lambda (x) (query n query-word x)) cs))) (if (<= d n) (cons root-word ms) ms)))
'(define *edit-distance* 2)
'(define *corpus-path* "/usr/share/dict/words")
'(define *corpus-port* (open-input-file *corpus-path*))
'(define get-next-word! (lambda () (define line (read-line-from-port *corpus-port*)) (if (symbol? line) #false (trim line))))
'(define generate (lambda (bktree func) (define next-word (func)) (if next-word (if (> 6 (string-length next-word)) (generate (insert-word bktree next-word) func) (generate bktree func)) bktree)))
'(define read-to-list (lambda (lst) (define next-word (get-next-word!)) (if next-word (read-to-list (cons next-word lst)) lst)))
'(displayln "Lazily generating the bk tree")
'(define *bktree* (generate empty-bk-tree get-next-word!))
'(displayln "Done!")
'(define suggest (lambda (word) (query *edit-distance* word *bktree*)))